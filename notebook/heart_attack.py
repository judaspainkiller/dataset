# -*- coding: utf-8 -*-
"""heart_attack.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EpKOGp3SdMxcZmXpbvx7c6KgUSr2x5Nv

# Исследование данных об инфаркте миокарда

В нашем распоряжении есть файл с данными о пациентах, которые отображают состояние их здоровья.
На основании этих данных можно определить вероятность сердечнего приступа у пациента.

Откроем файл и посмотрим, какие данные в нем находятся
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from tqdm import tqdm
from sklearn.metrics import accuracy_score

import matplotlib.pyplot as plt
from matplotlib import font_manager
plt.rcParams['font.family'] = 'DejaVu Sans'
import numpy as np
import seaborn as sns


data = pd.read_csv('/content/heart.csv')

data.head(10)

data.sample(10)

data.tail()

data.info()

data.isna().sum()

data.hist(figsize=(15, 20))

# к сожалению, автор данного датасета не оставил подробных комментариев о том, что конкретно обозначает каждый столбец и каждое значение,
# поэтому придется разбираться с этим путем обращения к интернету, переводчику и медицинским справочникам

"""# Обозначения столбцов:

age - возраст пациента

sex - пол пациента

cp - боль в груди (1:типичная стенокардия, 2:атипичная стенокардия, 3:неангинальная боль, 4:бессимптомная)

trtbps - кровяное давление в состоянии покоя

chol - уровень холестерина в мг/дл, определяется с помощью ИМТ пациента

fbs - (уровень сахара в крови натощак > 120 мг/дл) (1 = верно; 0 = ложно)

restecg - результаты электрокардиограммы в состоянии покоя (0: в норме, 1: наличие аномалии зубца ST-T (инверсии зубца T и/или подъем или понижение ST > 0,05 мВ), 2: наличие вероятной или определенной гипертрофии левого желудочка по критериям Эстеса)

thalachh - максимальный пульс

exng - стенокардия, вызванная физической нагрузкой (1 = да; 0 = нет)

oldpeak - показатель степени ишемии миокарда

slp -  структурированная световая плетизмография

caa - количество крупных судов (0-3)

thall - показатель талассемии (талассемия - заболевание крови, при котором у человека образуется недостаточно гемоглобина)

output - результат

#Вывод

1.Названия данных не соответствуют правилам наименования переменных в Python

2.Всего 303 значения. Пропущенных значений нет

3.Некоторые переменные имеют неправильный тип данных:


fbs - тип int, должен быть bool

exng - тип int, должен быть bool

output - тип int, должен быть bool (есть два значения: 0 - вероятность инфаркта низкая, 1 - вероятность инфаркта высокая)

# Предобработка данных

Для удобства работы с данными нужно переименовать столбцы
"""

data.rename(columns={'cp':'chest_pain', 'trtbps':'blood_pressure', 'chol':'cholesterol','fbs':'blood_sugar','restecg':'electrocardiogram',
                     'thalachh':'max_heart_rate', 'exng': 'angina_pectoris', 'oldpeak':'myocardial_ischemia_degree',
                     'slp':'structed_light_plethysmography', 'caa':'large_vessels', 'thall':'thalassemia'}, inplace = True)
data.columns

data.head(10)

"""# Продублируем обозначения столбцов с новыми названиями:

age - возраст пациента

sex - пол пациента (0 - женский, 1 - мужской)

chest_pain - боль в груди (1:типичная стенокардия, 2:атипичная стенокардия, 3:неангинальная боль, 4:бессимптомная)

blood_pressure - кровяное давление в состоянии покоя

cholesterol - уровень холестерина в мг/дл, определяется с помощью ИМТ пациента

blood_sugar - (уровень сахара в крови натощак > 120 мг/дл) (True = верно; False = ложно)

electrocardiogram - результаты электрокардиограммы в состоянии покоя (0: в норме, 1: наличие аномалии зубца ST-T (инверсии зубца T и/или подъем или понижение ST > 0,05 мВ), 2: наличие вероятной или определенной гипертрофии левого желудочка по критериям Эстеса)

max_heart_rate - максимальный пульс

angina_pectoris - стенокардия, вызванная физической нагрузкой (True = да; False = нет)

myocardial_ischemia_degree - показатель степени ишемии миокарда

strustured_light_plethysmography -  структурированная световая плетизмография

large_vessels - количество крупных судов (0-3) : 0 - сосуды в порядке, 1, 2, 3 указывают на поражение коронарных артерий

thalassemia - показатель талассемии (талассемия - заболевание крови, при котором у человека образуется недостаточно гемоглобина): 0 - бессимптомная форма, 1 - легкое течение болезни, 2 - тяжелое течение болезни, 3 - практически несовместимое с жизнью течение болезни

output - результат(False - вероятность инфаркта низкая, True - вероятность инфаркта высокая)
"""

data.rename(columns={'angina pectoris':'angina_pectoris'}, inplace = True)

"""Теперь поменяем тип данных у некоторых столбцов"""

data['blood_sugar'] = data['blood_sugar'].astype('bool')

data.info()

data['angina_pectoris'] = data['angina_pectoris'].astype('bool')
data['output'] = data['output'].astype('bool')

data.info()

"""# Промежуточный вывод:

1. Изменены названия столбцов
2. Изменены некоторые типы данных
"""

data.describe()

display(data)



"""#Исследование данных"""

len(data[data.output == 0])
# кол-во людей, у которых вероятность инфаркта низкая

len(data[data.output == 1])
# кол-во людей, у которых вероятность инфаркта высокая

"""Рассмотрим зависимость заболевания от пола пациента"""

gender_dict=data['sex'].value_counts()
fig = plt.figure(figsize=(10, 7))
plt.pie(gender_dict, labels=['мужчина', 'женщина'], autopct="%0.2f%%",explode = (0,0.05))

plt.show()

"""Из графика видно, что мужчин больше, чем женщин, однако это говорит только о количестве пациентов определенного пола в списке.

Рассмотрим процент заболеваний для каждого пола:
"""

pd.crosstab(data.sex,data.output).plot(kind="bar",figsize=(10,6),color=['tomato', 'lightskyblue' ])
plt.title('Заболевания для каждого пола')
plt.xlabel('Пол (0 = женский, 1 = мужской)')
plt.xticks(rotation=0)
plt.legend(["Не болен", "Страдает пороком сердца"])
plt.ylabel('Номер')
plt.show()

"""Из графика видно, что женщины имеют большую склонность с инфаркту, чем мужчины.

Теперь посмотрим на связь возраста и заболевания:
"""

pd.options.mode.chained_assignment = None
fig,axes=plt.subplots(2,2,figsize=(8,8))
age_dist=data[['age','output']]
age_dist['age_range']=pd.cut(age_dist['age'],bins=[0,18,40,66,200],include_lowest=True,right=False,
                             labels=['ребенок','молодежь','взрослый','пожилой'])
sns.countplot(x='age_range',hue='output',data=age_dist,ax=axes[0,0],palette="Set2")

axes[0,0].set_xlabel("поколение")

youth=age_dist[age_dist['age_range']=='молодежь']['output'].value_counts()
axes[0,1].pie(youth,labels=['Здоровый','Больной'],autopct='%.2f%%',colors = ['tomato', 'lightskyblue'])
axes[0,1].set_title('Доля заболевших молодых людей')

youth=age_dist[age_dist['age_range']=='взрослый']['output'].value_counts()
axes[1,0].pie(youth,labels=['Здоровый','Больной'],autopct='%.2f%%',colors = ['tomato', 'lightskyblue'])
axes[1,0].set_title('Доля заболевших взрослых')

youth=age_dist[age_dist['age_range']=='пожилой']['output'].value_counts()
axes[1,1].pie(youth,labels=['Здоровый','Больной'],autopct='%.2f%%',colors = ['tomato', 'lightskyblue'])
axes[1,1].set_title('Доля заболевших пожилых')

"""Как можно видеть из графика, среди пожилых людей болезни сердца встречаются чаще, чем среди взрослых и молодых людей.

Почти половина всех людей, старше 66 лет, имеет высокий риск получить инфаркт.
Однако среди взрослых (от 40 до 66 лет) этот показатель тоже довольно высокий.
Самые низкие значения среди молодежи - там всего 1/4 страдают от болезней сердца.


"""

len(data[data.age < 18])

"""А поскольку людей, младше 18 лет, в таблице нет, то оценить вероятность заболевания среди детей не получится.

Теперь посмотрим на взаимосвязь пульса, давления и инфаркта:
"""

plt.scatter(x=data.max_heart_rate[data.output==1], y=data.blood_pressure[data.output==1], c="#FFA773")
plt.scatter(x=data.max_heart_rate[data.output==0], y=data.blood_pressure[data.output==0], c="#8DE0FF")
plt.legend(["Больной",'Не болен'])
plt.xlabel("Пульс")
plt.ylabel("Давление")
plt.show()

"""Из диаграммы рассеивания видно, что корреляция между пульсом и давлением очень слабая. Т.е. нельзя сказать, что чем выше пульс, тем выше давление, и наоборот.

Также из диаграммы видно, что пульс и давление не гарантируют заболевания сердца. Например, изображено, что у двух пациентов с примерно одинаковыми показателями (пульс ~160 и давление чуть больше 100) диагнозы разные: один здоров, другой нет.

Посмотрим, как связаны боли в груди и заболевания сердца:
"""

fig,ax=plt.subplots(figsize=(14,5))
sns.countplot(x='chest_pain',data=data,hue='output',palette='Set2')
ax.set_xlabel('Типы боли в груди')

"""Справка обозначения болей в груди -

0:типичная стенокардия, 1:атипичная стенокардия, 2:неангинальная боль, 3:бессимптомная

Как показано на графике, большинство болеющих страдают от боли 2-го типа - неанглинальной (т.е. это не стенокардия). Большинство тех, кто имеет типичную стенокардию, тем не менее, здоровы и не имеют риска инфаркта.

Для интереса посмотрим, существует ли зависимость между уровнем сахара в крови  и вероятность инфаркта:


"""

pd.crosstab(data.blood_sugar,data.output).plot(kind="bar",figsize=(10,6),color=['tomato', 'lightskyblue' ])
plt.title('Сахар в крови')
plt.xlabel('Cахар > 120 мг/дл(False = неверно, True = верно)')
plt.xticks(rotation=0)
plt.legend(["Не болен", "Страдает пороком сердца"])
plt.ylabel('Номер')
plt.show()

"""Результат получился интересный: если судить по графику, то низкий уровень сахара в крови (ниже 120 мг/дл) есть у большей части заболевших. Таким образом, высокий уровень сахара в крови практически не влияет на вероятность получить инфаркт.

#Едем дальше.

Есть ли корреляция между уровнем холестерина и пульсом? Попробуем узнать:
"""

plt.scatter(x=data.max_heart_rate[data.output==1], y=data.cholesterol[data.output==1], c="#FF8C69")
plt.scatter(x=data.max_heart_rate[data.output==0], y=data.cholesterol[data.output==0], c="#8DE0FF")
plt.legend(["Больной",'Не болен'])
plt.xlabel("Пульс")
plt.ylabel("Холестерин")
plt.show()

"""Из графика видно, что корреляция очень слабая. Настолько слабая, что ее практически нет.

Вот еще интересный график (уже про возраст и холестерин):
"""

plt.scatter(x=data.age[data.output==1], y=data.cholesterol[data.output==1], c="#FF8C69")
plt.scatter(x=data.age[data.output==0], y=data.cholesterol[data.output==0], c="#8DE0FF")
plt.legend(["Больной",'Не болен'])
plt.xlabel("Возраст")
plt.ylabel("Холестерин")
plt.show()

"""Теперь проанализируем результаты электрокардиограммы в состоянии покоя:"""

fig,ax=plt.subplots(figsize=(14,5))
sns.countplot(x='electrocardiogram',data=data,hue='output',palette='Set2')
plt.legend(['Здоров', 'Нездоров'])
ax.set_xlabel('Результат электрокардиограммы')

"""Очень большое число заболевших пациентов имеют результат электрокардиограммы 1 (наличие аномалии зубца ST-T (инверсии зубца T и/или подъем или понижение ST > 0,05 мВ). в переводе на язык обывателей это обозначает, что у вас могут быть проблемы с сердечком, сходите к кардиологу на всякий пожарный).
Тем не менее, больные также могут иметь результат кардиограммы 0 т.е. без отклонений.

А может ли стенокардия иметь влияние? Сейчас узнаем:
"""

pd.crosstab(data.angina_pectoris,data.output).plot(kind="bar",figsize=(10,6),color=['tomato', 'lightskyblue' ])
plt.title('Стенокардия при физических нагрузках')
plt.xlabel('Стенокардия(False = неверно, True = верно)')
plt.xticks(rotation=0)
plt.legend(["Не болен", "Страдает пороком сердца"])
plt.ylabel('Номер')
plt.show()

"""Занимательно: несмотря на отсутствие стенокардии, большое число пациентов подвержено инфаркту.

Напоследок посмотрим на показатели талассемии:
"""

fig,ax=plt.subplots(figsize=(14,5))
sns.countplot(x='thalassemia',data=data,hue='output',palette='Set2')
plt.legend(['Здоров', 'Нездоров'])
ax.set_xlabel('Талассемия')

"""Напомним определение талассемии:

талассемия - заболевание крови, при котором у человека образуется недостаточно гемоглобина: 0 - бессимптомная форма, 1 - легкое течение болезни, 2 - тяжелое течение болезни, 3 - практически несовместимое с жизнью течение болезни

Таким образом, большое число заболевших страдают от тяжелой талассемии

Выбросы в данных есть, но минимальные, поэтому не будем их удалять, т.к. мало шансов, что они повлияют на итоговый результат.

(кроме этого, при попытке удалить выбросы, точность модели снизилась :|)

#Выводы:

1.Высокую вероятность имеют пожилые люди (старше 66 лет).

2.Неадекватные результаты электрокардиограммы указывают на заболевания сердца.

3.Женщины заболевают чаще мужчин.

4.При высокой вероятности инфаркта боль в груди чаще всего не связана с ишемией т.е. неангинальная.

5.Уровень сахара в крови, пульс и уровень холестерина практически никак не влияют на инфаркт миокарда.

6.Если у пациента тяжелая талассемия, то вероятность инфаркта повышается.

7.Стенокардия при физических нагрузках почти никакого значения при заболеваниях сердца не имеет.

#Построение модели машинного обучения

Деление на выборки
"""

target = data['output']
features = data.drop('output', axis=1)

target

features

features, features_train, target, target_train = train_test_split(
    features, target, test_size=0.4, random_state=12345, stratify=target
)

features_test, features_valid, target_test, target_valid = train_test_split(
    features, target, train_size=0.5, random_state=12345, stratify=target
)

features_train.shape

features_test.shape

features_valid.shape

122+90+91

target_train.shape

"""Напишем модель. Используем алгоритм дерева решений:"""

# Commented out IPython magic to ensure Python compatibility.
# %time
best_model_dt = None
best_model_dt_deth = 0
best_model_dt_leaf = 0
best_model_dt_split = 0
best_result_dt = 0
for depth in tqdm(range(1, 11)):
  for i in range(1, 46):
    for j in range(2, 26):
      model_dt = DecisionTreeClassifier(random_state=12345, max_depth=depth, min_samples_leaf=i, min_samples_split=j)
      model_dt.fit(features_train, target_train)
      predictions_dt = model_dt.predict(features_valid)
      result_dt = accuracy_score(target_valid, predictions_dt)
      if result_dt > best_result_dt:
        best_model_dt = model_dt
        best_model_dt_deth = depth
        best_model_dt_leaf = i
        best_model_dt_split = j
        best_result_dt = result_dt
print(f'Лучший результат: {best_result_dt}')
print(f'''Гиперпараметры:
    max_depth = {best_model_dt_deth}
    min_samples_leaf = {best_model_dt_leaf}
    min_samples_split = {best_model_dt_split}
''')

"""Точность составила 87%, максимальная глубина дерева - 4, минимальное кол-во листов на дереве - 6, минимальное кол-во веток - 2.

А теперь посмотрим, какой результат будет, если использовать алгоритм случайного леса:
"""

# Commented out IPython magic to ensure Python compatibility.
# %time
best_model_dt = None
best_model_dt_deth = 0
best_model_n_estimators = 0
best_result_dt = 0
for depth in tqdm(range(1, 31)):
  for i in range(1, 61):
      model_dt = RandomForestClassifier(random_state=12345, max_depth=depth, n_estimators = i)
      model_dt.fit(features_train, target_train)
      predictions_dt = model_dt.predict(features_valid)
      result_dt = accuracy_score(target_valid, predictions_dt)
      if result_dt > best_result_dt:
        best_model_dt = model_dt
        best_model_dt_deth = depth
        best_result_dt = result_dt
        best_model_n_estimators = i
print(f'Лучший результат: {best_result_dt}')
print(f'''Гиперпараметры:
    max_depth = {best_model_dt_deth}
    n_estimators = {best_model_n_estimators}
''')

"""Точность составляет 90%, максимальная глубина - 1, кол-во деревьев - 40.

#Заключение

Была написана модель машинного обучения, определяющая вероятность инфаркта у пациента. Для этого использовался готовый датасет с данными о состоянии здоровья пациентов. Данные были подготовлены для работы, а также изучены.

В модели использовались два алгоритма: алгоритм дерева решений и алгоритм случайного леса. Алгоритм случайного леса показал более высокую точность, чем алгоритм дерева решений, однако он занимает больше времени по сравнению с другим алгоритмом.
"""

